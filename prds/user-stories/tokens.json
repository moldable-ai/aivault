{
  "schemaVersion": 2,
  "domain": "tokens",
  "title": "Token Model And Operator APIs",
  "evidence": [
    {
      "id": "ev-broker-token-operator-and-proxy-class-separation-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_operator_and_proxy_class_separation"
      ]
    },
    {
      "id": "ev-broker-token-proxy-scope-capability-and-credential-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_proxy_scope_capability_and_credential"
      ]
    },
    {
      "id": "ev-broker-token-proxy-ttl-and-context-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_proxy_ttl_and_context"
      ]
    },
    {
      "id": "ev-broker-token-proxy-broker-endpoints-only-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_proxy_broker_endpoints_only"
      ]
    },
    {
      "id": "ev-broker-token-opaque-server-side-validation-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_opaque_server_side_validation"
      ]
    },
    {
      "id": "ev-broker-token-credential-pin-auto-resolution-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_credential_pin_auto_resolution"
      ]
    },
    {
      "id": "ev-broker-token-mint-proxy-endpoint-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_mint_proxy_endpoint"
      ]
    },
    {
      "id": "ev-broker-token-mint-validates-capability-provider-compatibility-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_mint_validates_capability_provider_compatibility"
      ]
    },
    {
      "id": "ev-broker-token-localhost-default-enforcement-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_localhost_default_enforcement"
      ]
    },
    {
      "id": "ev-broker-token-operator-crud-surface-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_operator_crud_surface"
      ]
    },
    {
      "id": "ev-broker-token-operator-secret-crud-isolated-from-proxy-test",
      "kind": "tests",
      "automated": true,
      "file": "src/broker/tests.rs",
      "tests": [
        "story_token_operator_secret_crud_isolated_from_proxy"
      ]
    },
    {
      "id": "ev-vault-token-operator-system-managed-secrets-test",
      "kind": "tests",
      "automated": true,
      "file": "src/vault/mod.rs",
      "tests": [
        "system_secrets_are_persisted_as_system_managed"
      ]
    }
  ],
  "sections": [
    {
      "id": "token-auth-classes",
      "group": "Tokens",
      "title": "Token Separation And Scope",
      "stories": [
        {
          "slug": "token-operator-and-proxy-class-separation",
          "story": "As a security reviewer, I want operator and proxy auth classes kept separate, so execution-scoped bearer tokens cannot perform admin actions.",
          "evidenceLinks": [
            "ev-broker-token-operator-and-proxy-class-separation-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-operator-and-proxy-class-separation-test",
                "test": "story_token_operator_and_proxy_class_separation"
              }
            ]
          }
        },
        {
          "slug": "token-proxy-scope-capability-and-credential",
          "story": "As a runtime integrator, I want proxy tokens scoped to capabilities and optionally credential id, so execution access is minimized and account routing is deterministic.",
          "evidenceLinks": [
            "ev-broker-token-proxy-scope-capability-and-credential-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-proxy-scope-capability-and-credential-test",
                "test": "story_token_proxy_scope_capability_and_credential"
              }
            ]
          }
        },
        {
          "slug": "token-proxy-ttl-and-context",
          "story": "As a runtime integrator, I want proxy tokens short-lived and tied to execution context metadata, so stolen tokens have limited lifetime and audit context.",
          "evidenceLinks": [
            "ev-broker-token-proxy-ttl-and-context-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-proxy-ttl-and-context-test",
                "test": "story_token_proxy_ttl_and_context"
              }
            ]
          }
        },
        {
          "slug": "token-proxy-broker-endpoints-only",
          "story": "As a security reviewer, I want proxy tokens valid only on broker/proxy endpoints, so untrusted code cannot call operator CRUD routes.",
          "evidenceLinks": [
            "ev-broker-token-proxy-broker-endpoints-only-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-proxy-broker-endpoints-only-test",
                "test": "story_token_proxy_broker_endpoints_only"
              }
            ]
          }
        },
        {
          "slug": "token-opaque-server-side-validation",
          "story": "As a security reviewer, I want proxy tokens validated only from server-side token state, so forged bearer strings with matching prefixes are rejected.",
          "evidenceLinks": [
            "ev-broker-token-opaque-server-side-validation-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-opaque-server-side-validation-test",
                "test": "story_token_opaque_server_side_validation"
              }
            ]
          }
        },
        {
          "slug": "token-credential-pin-auto-resolution",
          "story": "As a runtime integrator, I want credential-pinned proxy tokens to resolve credentials when request.credential is omitted, so callers remain simple in multi-account setups.",
          "evidenceLinks": [
            "ev-broker-token-credential-pin-auto-resolution-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-credential-pin-auto-resolution-test",
                "test": "story_token_credential_pin_auto_resolution"
              }
            ]
          }
        }
      ]
    },
    {
      "id": "token-mint-and-admin",
      "group": "Tokens",
      "title": "Minting And Operator API Surface",
      "stories": [
        {
          "slug": "token-mint-proxy-endpoint",
          "story": "As a trusted runtime, I want an operator-authenticated proxy token mint endpoint that returns opaque token plus expiry, so callers can receive scoped access without admin credentials.",
          "evidenceLinks": [
            "ev-broker-token-mint-proxy-endpoint-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-mint-proxy-endpoint-test",
                "test": "story_token_mint_proxy_endpoint"
              }
            ]
          }
        },
        {
          "slug": "token-mint-validates-capability-provider-compatibility",
          "story": "As a broker, I want token mint to reject credential and capability combinations across different providers, so impossible policy bindings fail before issuance.",
          "evidenceLinks": [
            "ev-broker-token-mint-validates-capability-provider-compatibility-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-mint-validates-capability-provider-compatibility-test",
                "test": "story_token_mint_validates_capability_provider_compatibility"
              }
            ]
          }
        },
        {
          "slug": "token-localhost-default-enforcement",
          "story": "As an operator, I want broker binding loopback-only by default with non-loopback clients rejected unless explicitly enabled, so local tokens are not remotely usable by default.",
          "evidenceLinks": [
            "ev-broker-token-localhost-default-enforcement-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-localhost-default-enforcement-test",
                "test": "story_token_localhost_default_enforcement"
              }
            ]
          }
        },
        {
          "slug": "token-operator-crud-surface",
          "story": "As an operator, I want authenticated CRUD APIs for credentials and capabilities plus proxy token minting, so policy and account lifecycle are managed outside untrusted execution.",
          "evidenceLinks": [
            "ev-broker-token-operator-crud-surface-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-operator-crud-surface-test",
                "test": "story_token_operator_crud_surface"
              }
            ]
          }
        },
        {
          "slug": "token-operator-secret-crud-isolated-from-proxy",
          "story": "As an operator, I want operator secrets CRUD protected by operator auth and unavailable to proxy tokens, so runtime system secrets cannot be mutated by executing code.",
          "evidenceLinks": [
            "ev-broker-token-operator-secret-crud-isolated-from-proxy-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "runtime": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_proxy_token"
              }
            ],
            "guards": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::ensure_operator"
              }
            ],
            "stateEffects": [
              {
                "file": "src/broker/runtime.rs",
                "symbol": "Broker::mint_proxy_token"
              }
            ],
            "userSurface": [
              {
                "file": "src/broker.rs",
                "symbol": "PlannedRequest"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-broker-token-operator-secret-crud-isolated-from-proxy-test",
                "test": "story_token_operator_secret_crud_isolated_from_proxy"
              }
            ]
          }
        },
        {
          "slug": "token-operator-system-managed-secrets",
          "story": "As an operator, I want system-managed operator secrets represented with immutable-by-runtime metadata semantics, so runtime code cannot edit broker-owned secret records directly.",
          "evidenceLinks": [
            "ev-vault-token-operator-system-managed-secrets-test"
          ],
          "trace": {
            "proofLevel": "runtime",
            "entrypoints": [
              {
                "file": "src/vault/mod.rs",
                "symbol": "VaultRuntime::create_system_secret"
              }
            ],
            "runtime": [
              {
                "file": "src/vault/mod.rs",
                "symbol": "VaultRuntime::set_secret_system_managed"
              }
            ],
            "guards": [
              {
                "file": "src/vault/mod.rs",
                "symbol": "VaultRuntime::create_secret_with_management"
              }
            ],
            "stateEffects": [
              {
                "file": "src/vault/mod.rs",
                "symbol": "VaultRuntime::write_secret"
              }
            ],
            "userSurface": [
              {
                "file": "src/vault/store.rs",
                "symbol": "SecretMeta"
              }
            ],
            "assertions": [
              {
                "evidenceId": "ev-vault-token-operator-system-managed-secrets-test",
                "test": "system_secrets_are_persisted_as_system_managed"
              }
            ]
          }
        }
      ]
    }
  ]
}
